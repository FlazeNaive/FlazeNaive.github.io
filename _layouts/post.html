---
layout: default
---
<!-- 引入你刚刚创建的样式文件 -->
<link rel="stylesheet" href="/assets/css/post.css">

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">{{ page.title | escape }}</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="{{ page.date | date_to_xmlschema }}" itemprop="datePublished">
        {{ page.date | date: "%b %-d, %Y" }}
      </time>
    </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    {{ content }}
  </div>

  <a class="u-url" href="{{ page.url | relative_url }}" hidden></a>
</article>

<!-- 引入 JS 库 -->
<script src="/assets/js/scrollnav.min.umd.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const content = document.querySelector('.post-content');
        
        if (content) {
            // 1. 初始化
            scrollnav.init(content, {
                debug: false,
                sections: 'h1, h2, h3',
                insertTarget: content,
                insertLocation: 'after'
            });

            // 2. 核心逻辑
            setTimeout(function() {
                const links = document.querySelectorAll('.scroll-nav__link');
                const items = document.querySelectorAll('.scroll-nav__item');
                const navList = document.querySelector('.scroll-nav__list');

                // --- A. 初始化类名 (h1/h2/h3) ---
                links.forEach(function(link) {
                    const href = link.getAttribute('href');
                    if (!href) return;
                    
                    let targetId = href.split('#')[1];
                    try { targetId = decodeURIComponent(targetId); } catch (e) {}

                    let targetElement = document.getElementById(targetId);
                    if (!targetElement) targetElement = document.getElementById(href.split('#')[1]);

                    if (targetElement) {
                        const level = targetElement.tagName.toLowerCase(); 
                        link.classList.add('toc-' + level);
                    }
                });

                // --- B. 折叠逻辑 ---
                function updateFolding() {
                    let currentGroup = []; 
                    let groupHasActive = false;

                    items.forEach((item) => {
                        const link = item.querySelector('.scroll-nav__link');
                        if (!link) return;

                        // 遇到 H1，结算上一组
                        if (link.classList.contains('toc-h1')) {
                            if (currentGroup.length > 0) {
                                applyVisibility(currentGroup, groupHasActive);
                            }
                            currentGroup = []; 
                            groupHasActive = false;
                        }

                        currentGroup.push(item);

                        // 检查是否有高亮项
                        if (item.classList.contains('scroll-nav__item--active')) {
                            groupHasActive = true;
                        }
                    });

                    // 结算最后一组
                    if (currentGroup.length > 0) {
                        applyVisibility(currentGroup, groupHasActive);
                    }
                }

                function applyVisibility(group, shouldShow) {
                    group.forEach(item => {
                        // 如果这一组里有人被激活，就加上 show-group 类
                        if (shouldShow) {
                            item.classList.add('show-group');
                        } else {
                            item.classList.remove('show-group');
                        }
                    });
                }

                // --- C. 安全的监听器 (防止死循环) ---
                if (navList) {
                    // 1. 先运行一次
                    updateFolding();

                    // 2. 创建监听器
                    const observerConfig = { 
                        attributes: true, 
                        subtree: true, 
                        attributeFilter: ['class'] // 只监听 class 变化
                    };

                    const observer = new MutationObserver(function(mutations) {
                        // !!! 关键修复：检测到变化后，先断开监听 !!!
                        observer.disconnect();
                        
                        // 执行更新 (这会修改 class)
                        updateFolding();

                        // !!! 更新完后，重新连接监听 !!!
                        observer.observe(navList, observerConfig);
                    });
                    
                    // 启动监听
                    observer.observe(navList, observerConfig);
                }

            }, 100);
        }
    });
</script>